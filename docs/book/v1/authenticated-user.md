# Authenticated user

Once the user is authenticated, `zend-expressive-authentication-oauth2` stores
the user's authorization details in a PSR-7 attribute under the name `Zend\Expressive\Authentication\UserInterface`.

This attribute contains an object that implements the [UserInterface](https://github.com/zendframework/zend-expressive-authentication/blob/master/src/UserInterface.php).

This object contains all the information generated by [thephpleage/oauth2-server](https://github.com/thephpleague/oauth2-server),
including the following data:

```php
[
    'oauth_user_id' => /* user's identifier (string) */,
    'oauth_client_id' => /* the client id (string) */,
    'oauth_access_token_id' => /* the access token id (string) */,
    'oauth_scopes' => /* the scopes (mixed, usually an array) */
]
```

You may retrieve these values using the `getDetails()` method or individually
using the `getDetail($name)` method of the user instance. As an example:

```php
$user->getDetails(); // returns all the values, as array

$userId = $user->getDetail('oauth_user_id', false);
if (false !== $userId) {
    printf("The user ID is %s", $userId);
}
```

If you want to retrieve the identity of the user (or the client) you can also
use the `getIdentity()` function. This function returns the user's ID if it is
not null, otherwise it returns the client's ID.

The `getRoles()` function of the `UserInterface` object returns always an empty
array.

## Customize the user's object

If you wish to provide a custom `Zend\Expressive\Authentication\UserInterface`
implementation, you will need to provide:

- a custom implementation of the the interface
- a factory capable of generating instances of that interface
- a DI factory for generating the previous factory
- configuration wiring the `UserInterface` service to your factory.

The factory noted in the second step should be a callable with the following
signature:

```php
function (
    string $identity,
    array $roles = [],
    array $details = []
) : Zend\Expressive\Authentication\UserInterface
```

As an example of the factory in the third point, you will create a standard DI
factory to return it. It could, for instance, compose a database adapter o pull
information and create your custom user implementation:

```php
class CustomUserFactory
{
    public function __invoke(Psr\Container\ContainerInterface $container) : callable
    {
        $db = $container->get(Zend\Db\Adapter\AdapterInterface::class);
        return function (string $identity, array $roles = [], array $details = []) use ($db) : Zend\Expressive\Authentication\UserInterface {
            // get some data from $db
            // return a new instance
            return new MyCustomUserType(/* ... */);
        });
    }
}
```

You will then need to wire this factory to the `UserInterface` service,
per the following example:

```php
// config/autoload/custom-user.local.php
return [
    'dependencies' => [
        'factories' => [
            UserInterface::class => CustomUserFactory::class,
        ]
    ]
];
```
